<!DOCTYPE html><html><head><title>Code Quality: Locality</title><meta name="description" content="Locality is an important measure of code quality, covering the where and when."><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="Content-type" content="text/html;charset=UTF-8"><meta name="author" content="Chris Andrejewski"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16.ico">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32.ico">
<link rel="icon" type="image/png" sizes="64x64" href="/favicon-64.ico">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G3SKTPFTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-G3SKTPFTEZ');
</script><link rel="stylesheet" href="/stylesheets/document.css"></head><body><div class="page"><div class="document"><div class="content"><h1>Code quality: Locality</h1>
<p>Locality is a measure of where code is organized and how it is interacted with. It's an important dimension to writing good code as it's the largest factor in development velocity.</p>
<p>In general, you want good locality between relevant pieces of code. It's like writing a good story: you explain things in a certain order and a series of events are located in the same chapter. However, in a sufficiently large code base, not everything can be local and you would not want it to be anyway: too many things are hard to reason about. The story would be too long and you don't have time to read it all.</p>
<h2>Placement</h2>
<p>Locality at a more &quot;physical&quot; level is how things are grouped:</p>
<ul>
<li>Similar methods are grouped together within a section of a file</li>
<li>Similar sections are grouped into a file</li>
<li>Similar files are grouped in a directory</li>
<li>Similar directories are grouped into a package, repo, and so on</li>
</ul>
<p>The elephant in the room is “what does similar mean?” There are two trains of thought:</p>
<ul>
<li>Group by type of thing</li>
<li>Group by feature or concern</li>
</ul>
<p>Supposing we have a simple app with users logging in and checking their bank balance, if we were to group by type of thing we'd have:</p>
<pre><code>my-app/
  models/
    user
    user_session
    bank_account
    balance_entries
  views/
    login
    logout
    balance_page
  servers/
    primary
</code></pre>
<p>And this same structure grouped by feature we'd have:</p>
<pre><code>my-app/
  authentication/
    user
    user_session
    login
    logout
  banking
    bank_account
    balance_entries
    balance_page
  servers/
    primary
</code></pre>
<p>In this feature (or “concern”) case, you'll notice that <code>servers</code> remain the same as presumably the server is hosting both the authentication and the banking features.
It does not distinctly belong in one or the other.
In each style there will be things that don't all fit into neat boxes.</p>
<p>But let's compare these two approaches:</p>
<ul>
<li>
<p>Grouping by type of thing, it's immediately obvious how many things of each type there are. For example, we can plainly see there are 4 models. However, with all models placed in the same folder, it is hard to conceptually drive a wedge between how models are used and how they ought to interact.</p>
</li>
<li>
<p>Grouping by feature, it's immediately clear that <code>user_session</code> is for authentication and <code>balance_entry</code> is for banking. However, what is a model and what is a view we cannot be certain.</p>
</li>
</ul>
<p>When we consider change management, the &quot;type of thing&quot; approach is generally more optimal for the &quot;type of thing&quot; team to work on: everything they need to touch regarding the big picture of models is in one place. It's easier to make sweeping changes to all models and oversee their usages. The feature approach is more optimal for feature developers as the elements that compose into a useful feature are in one place and can be iterated on is lockstep. Ideally if an entire feature is made obsolete, you can simply delete the feature's folder and move on.</p>
<p>There's an inherent struggle here on which locality scheme is optimal. In my experience which style is adopted in a given situation is oriented around the organization of people working on the code. An infrastructure team will naturally bias towards the &quot;type of thing&quot; they are responsible for: this code structure is neat and orderly for them. A product team will group by feature as that's how they iterate: building feature after feature, some succeed and some fail. They are primarily responsible for producing value, not organizing things such that they can steward a single feature long term or maintain it indefinitely.</p>
<p>I recommend a balanced approach here where infrastructure teams and product teams are catered to. The reasoning:</p>
<ul>
<li>
<p><strong>Product teams are nomadic.</strong> Once a feature is built, they move on. This is optimal: innovation comes from chasing, taking risks, and failing. With this mobility and churn, knowledge transfer breaks down more readily: people come and go and don't understand the things that have been built. As such you want to allow product teams the liberty to isolate features and draw proper boundaries. Those isolated features that do succeed tend to be easier for infrastructure teams to adopt and champion.</p>
</li>
<li>
<p><strong>Infrastructure teams grind.</strong> All those successful features become entrenched and hard to change. Strewn throughout a codebase with no way to grok the big picture and make cross-feature changes to these common types of things leaves infrastructure teams in a tough spot. They may not be able to dig themselves out of a hole and in the meantime product teams working in isolation in aggregate exacerbate the problems. In order for infrastructure teams to keep pace with product teams, they need to be trailing but not too far behind.</p>
</li>
<li>
<p><strong>Culture and leadership are major factors.</strong> Leaders who value features and won't see the value in infrastructure see developer velocity grind to halts. Leaders who allow the infrastructure to always be tip-top never see features. Interestingly, in these environments, the best engineers are often running the unspoken counter-culture: incremental releases of features and continual, strategic investment in velocity. This is the balanced approach.</p>
</li>
</ul>
<p>A balanced approach to the above, in which you can enable both styles to coexist, looks like:</p>
<pre><code>my-app/
  authentication/
    models/
      user
      user_session
    views/
      login
      logout
  banking
    models/
      bank_account
      balance_entries
    views/
      balance_page
  servers/
    primary
</code></pre>
<p>We can build tools to observe code structured in this format using both product and infrastructure lenses.
We treat the <code>authentication</code> and <code>banking</code> directories as features (more commonly called modules or packages), modeling them as a &quot;type of thing.&quot;
We build tooling to support introspecting these features in aggregate, e.g. &quot;Give me a list of all the features.&quot;</p>
<p>This serves as a starting point to drive a consistent structure within features.
For example, enforce that all models must live in the <code>${feature}/models</code> directory.
Now we can get all of the models by querying for all models within each feature.
In this case, product teams write against a prescribed pattern but otherwise code how they want to model and work out a problem.
And infrastructure teams can still understand the big picture and make sweeping changes across models as they need.</p>
<p>At a macro-level code locality is an approximation of the organization of people which maintain the code. Expect the optimal locality to change over a feature's lifetime.</p>
<h2>Immediacy</h2>
<p>Code locality is an optimization problem of:</p>
<ol>
<li>Make code easier to find.</li>
<li>Make code easier to read. (If you can't find it, you can't read it.)</li>
<li>Make code easier to change. (If you can't read it, good luck changing it.)</li>
</ol>
<p>Logical and consistent grouping, in addition to search tools, make finding code much easier than without. This is the fundamental prerequisite to any development not starting from scratch. That grouping aids in reading: it's the difference between reading a chaotic novel and a beloved short story. And finally, accomplishing a change in a single grouping is much easier than making a single change in dozens of disparate places.</p>
<p>But great code locality is not merely about the right place. It is also about the right time. Discovery, readability, and iteration can be aided by a spectrum of tools and engineers ought to be diligent and mindful of taking advantage of them.</p>
<p>Here's a list of assistive tools sorted from best to worse:</p>
<ul>
<li>Auto-complete</li>
<li>Type-checking</li>
<li>Tests</li>
<li>Code comments</li>
<li>Documentation</li>
<li>Human assistance</li>
</ul>
<p>The &quot;right time&quot; with regard to code locality is almost always as soon as possible. Auto-complete helps you type, type-checking helps you as you type (in most interactive development environments (IDEs)), tests help you as you save changes locally (if they are fast enough (so make them fast)). Code comments, documentation, and other humans help provide context not encoded (and perhaps outdated); each being progressively slower to find/use.</p>
<p>One instance in which timeliness of code locality should not be ASAP is when it results in an intractable proliferation of options. So called &quot;over-choice&quot; is a burden and distraction as it presents the developer new problems to solve, not solutions to their problems.</p>
<p>Another instance in which ASAP timeliness is not optimal is when it creates poor code quality. A common example of this is the abuse of code-generation tools. Often engineers struggle to properly encode a comprehensive and minimal interface and resort to generating massive amounts of boilerplate code. This is a form of auto-complete which can be actively harmful, littering a code base with inconsistency and noise that can be difficult to claw back. Helping fellow engineers write bad code faster is not worth doing. More timely and easy to use tools must create positive feedback loops.</p>
<p>Leveraging code locality on this dimension is a potential boon for every engineer:</p>
<ul>
<li>
<p>For product engineers, a more precise modeling and shorter feedback loops lead to faster development and fewer bugs.</p>
</li>
<li>
<p>For infrastructure engineers, leveraging these tools makes the features they support more self-service; freeing them up to support product teams in more domains.</p>
</li>
</ul>
<p>However, the rub is leveraging these assistive tools generally takes more of an engineer's immediate time. You would not want to build a collection of auto-complete snippets for something that turns out to never be used. You must be judicious in deciding at what rung you ought to help yourself and fellow developers compared to delivering the features themselves.</p>
<p>This is yet again a place where I recommend the balanced approach: incremental releases of features and continual, strategic investment in velocity.</p>
<p>Infrastructure teams do well to allow product teams to try a bunch of things, see what sticks, and then encode and elevate the victors. Product teams do well to explicitly model and encode the domain they are working in such that they succeed in building features. This is why we see strong engineering cultures enforce bare minimums, for example, that all code must have tests or that all code must have type annotations.</p>
<hr>
<p>Locality is a balancing act in two aspects: placement and timeliness.</p>
<p>In regards to placement, the correct approach is a trade off of who to cater to, e.g. who is the audience. Above we juxtaposed infrastructure and product teams, but we can have many more audiences than that: non-technical people (e.g. needing to introspect/audit the system) and even computers and the technical limitations they present us (e.g. constraints of hardware and distributed systems).</p>
<p>For timeliness, we weigh investing in velocity versus features. We consider the tools at our disposal to help us write code faster and better.</p>
<p>In each dimension, moderation and incremental, continual investment is the best path forward between possible extremes.</p>
<time>Published Monday, June 20, 2022</time></div></div></div></body></html>